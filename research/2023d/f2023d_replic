################################################################################
####
####   Fournel-2023d - Replication file
####
################################################################################


library(readxl)
library(clubSandwich)
library(ivreg)
library(reldist)
library(lattice)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)

setwd("C:/Users/Testis/Desktop/d_thesis/github/fournel2023d")


################################################################################
### Original datasets
################################################################################

#1999-2010 set 
rflc1 <- read.csv("fournel2023d_controls_iris_1999.csv",sep=";")
rflc2 <- read.csv("fournel2023d_controls_iris_2010.csv",sep=";")
v <- intersect(rflc1$iris2,rflc2$iris2)
rflc1<-subset(rflc1, (rflc1$iris2 %in% v))
rflc2<-subset(rflc2, (rflc2$iris2 %in% v))
rflc<-left_join(rflc1,rflc2, by=c("iris2"))
rflc$depcom <- substr(rflc$iris2,1,5)
aau <- read_excel("AAU.xls")
ref_geo <- read.csv("ref_geo.csv", sep=";")
ref_geo <- dplyr::rename(ref_geo, depcom = COM_CODE)
rflc <- left_join(rflc, ref_geo, by=c("depcom"))
rflc <- left_join(rflc, aau, by=c("depcom"))
rflc$Tcpis2010 <- rflc$cpis2010 / rflc$poptot2010
rflc$Tint2010 <- rflc$int2010 / rflc$poptot2010
rflc$Templ2010 <- rflc$empl2010 / rflc$poptot2010
rflc$Touvr2010 <- rflc$ouvr2010 / rflc$poptot2010
rflc$nativ2010 <-  rflc$poptot2010 -rflc$immig2010
cols = c(21:41)    
rflc[,cols] = apply(rflc[,cols], 2, function(x) as.numeric(as.character(x)))

#2010-2017
rflc <- read.csv("fournel2023d_census20102017.csv")



################################################################################
### Outcome of the two main algorithms
################################################################################

rflc2 <- read.csv("fournel2023d_thres_dec1.csv", sep=",")
rflc2 <- read.csv("fournel2023d_thres_dec2.csv", sep=",")
rflc <- rflc2

################################################################################
### TABLE - Main tipping specification (origin-based)
################################################################################


rflc2 <- read.csv("fournel2023d_thres_dec1.csv", sep=",")
rflc <- rflc2
rflc$zone <- substr(rflc$ZE_ID,3,3)
rflc$delta <- rflc$EXP - (rflc$thres_m1/100)
rflc$delta2 <- rflc$delta*rflc$delta
rflc$delta3 <- rflc$delta*rflc$delta*rflc$delta
rflc$delta4 <- rflc$delta*rflc$delta*rflc$delta*rflc$delta
rflc$dummy <- 0
for (i in c(1:dim(rflc)[1])){  if(rflc$delta[i] > 0) {rflc$dummy[i] <- 1}}

reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy, data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+Touvr_pop+chomage+sansdiplome+logementsvacants+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")

rflc$delta <- rflc$EXP - (rflc$thres_m2)
rflc$delta2 <- rflc$delta*rflc$delta
rflc$delta3 <- rflc$delta*rflc$delta*rflc$delta
rflc$delta4 <- rflc$delta*rflc$delta*rflc$delta*rflc$delta
rflc$dummy <- 0
for (i in c(1:dim(rflc)[1])){  if(rflc$delta[i] > 0) {rflc$dummy[i] <- 1}}
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy, data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+Touvr_pop+chomage+sansdiplome+logementsvacants+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")



rflc2 <- read.csv("fournel2023d_thres_dec2.csv", sep=",")
rflc <- rflc2
rflc$zone <- substr(rflc$ZE_ID,3,3)
rflc$delta <- rflc$EXP - (rflc$thres_m1/100)
rflc$delta2 <- rflc$delta*rflc$delta
rflc$delta3 <- rflc$delta*rflc$delta*rflc$delta
rflc$delta4 <- rflc$delta*rflc$delta*rflc$delta*rflc$delta
rflc$dummy <- 0
for (i in c(1:dim(rflc)[1])){  if(rflc$delta[i] > 0) {rflc$dummy[i] <- 1}}

reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy, data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+ouvr_2010+chomage+sansdiplome_2010+log_vac_2010+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")

rflc$delta <- rflc$EXP - (rflc$thres_m2)
rflc$delta2 <- rflc$delta*rflc$delta
rflc$delta3 <- rflc$delta*rflc$delta*rflc$delta
rflc$delta4 <- rflc$delta*rflc$delta*rflc$delta*rflc$delta
rflc$dummy <- 0
for (i in c(1:dim(rflc)[1])){  if(rflc$delta[i] > 0) {rflc$dummy[i] <- 1}}
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy, data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+ouvr_2010+chomage+sansdiplome_2010+log_vac_2010+factor(ZE_ID), data=rflc, weight=rflc$tot_pop)
summary(reg_lin)
coef_test(reg_lin, vcov = "CR1", cluster = rflc$ZE_ID, test = "naive-t")


################################################################################
### FIGURE - General tipping graph 
################################################################################

rflc2 <- read.csv("fournel2023d_thres_dec1.csv", sep=",")
rflc <- rflc2
rflc <- subset(rflc, rflc$EXP<0.45)
rflc$delta <- rflc$EXP - (rflc$thres_m1/100)
min1 <- min(rflc$delta, na.rm=TRUE)
max1 <- max(rflc$delta, na.rm=TRUE)
min1 <- trunc(min1*100)
max1 <- trunc(max1*100)
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){  y1$var[i-min1+1] <- mean(rflc$meandev[(rflc$delta > y1$y[i-min1+1]) & (rflc$delta < y1$y[i-min1+2])],na.rm=TRUE)}
xyplot(var  ~ y, y1)
y1 <- subset(y1, y1$var <0.2)
for (i in c(1:dim(y1)[1])){  y1$ind[i] <- if(y1$y[i]>0){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= 0))
y1b <- subset(y1, (y1$y <= 0))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
xyplot(var + fitted(lmb)  ~ y, y1b)
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){  if(y1$y[i] < 0){y1$fitc[i] <- NA}
  if(y1$y[i] > 0){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==0){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
vc<- c("#bdbdbd","#bdbdbd","#bdbdbd","#525252","#525252")
PLO1 <- xyplot(var + fita + fitb + fitc + fitc1 ~ y, data=y1,
               strip = FALSE, 
               pch = 1,
               type = c("p","l","l","l","l"),
               main="Method 1 (Structural break)",
               xlab="Distance from local tipping threshold",
               ylab="Evolution of native population",
               col=vc,
               abline=c(v=0, col=8), 
               distribute.type = TRUE) 


rflc$delta <- rflc$EXP - (rflc$thres_m2)
min1 <- min(rflc$delta, na.rm=TRUE)
max1 <- max(rflc$delta, na.rm=TRUE)
min1 <- trunc(min1*100)
max1 <- trunc(max1*100)
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){  y1$var[i-min1+1] <- mean(rflc$meandev[(rflc$delta > y1$y[i-min1+1]) & (rflc$delta < y1$y[i-min1+2])],na.rm=TRUE)}
xyplot(var  ~ y, y1)
y1 <- subset(y1, y1$var <0.2)
for (i in c(1:dim(y1)[1])){  y1$ind[i] <- if(y1$y[i]>0){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= 0))
y1b <- subset(y1, (y1$y <= 0))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
xyplot(var + fitted(lmb)  ~ y, y1b)
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){  if(y1$y[i] < 0){y1$fitc[i] <- NA}
  if(y1$y[i] > 0){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==0){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
vc<- c("#bdbdbd","#bdbdbd","#bdbdbd","#525252","#525252")
PLO2 <- xyplot(var + fita + fitb + fitc + fitc1 ~ y, data=y1,
               strip = FALSE, 
               pch = 1,
               type = c("p","l","l","l","l"),
               main="Method 2 (Fixed point)",
               xlab="Distance from local tipping threshold",
               ylab="",
               col=vc,
               abline=c(v=0, col=8), 
               distribute.type = TRUE) 


print(PLO1, position=c(0,0, 0.51,1), more=TRUE)
print(PLO2, position=c(0.49,0, 1,1))

################################################################################
### FIGURE - Tipping in some illustrative cities
################################################################################

rflc1 <- read.csv("fournel2023d_controls_iris_1999.csv",sep=";")
rflc2 <- read.csv("fournel2023d_controls_iris_2010.csv",sep=";")
v <- intersect(rflc1$iris2,rflc2$iris2)
rflc1<-subset(rflc1, (rflc1$iris2 %in% v))
rflc2<-subset(rflc2, (rflc2$iris2 %in% v))
rflc<-left_join(rflc1,rflc2, by=c("iris2"))
rflc$depcom <- substr(rflc$iris2,1,5)
aau <- read_excel("AAU.xls")
ref_geo <- read.csv("ref_geo.csv", sep=";")
ref_geo <- dplyr::rename(ref_geo, depcom = COM_CODE)
rflc <- left_join(rflc, ref_geo, by=c("depcom"))
rflc <- left_join(rflc, aau, by=c("depcom"))
rflc$Tcpis2010 <- rflc$cpis2010 / rflc$poptot2010
rflc$Tint2010 <- rflc$int2010 / rflc$poptot2010
rflc$Templ2010 <- rflc$empl2010 / rflc$poptot2010
rflc$Touvr2010 <- rflc$ouvr2010 / rflc$poptot2010
rflc$nativ2010 <-  rflc$poptot2010 -rflc$immig2010
cols = c(21:41)    
rflc[,cols] = apply(rflc[,cols], 2, function(x) as.numeric(as.character(x)))
secuu <- rflc[["ZE_ID"]]
secuu1 <- table(unlist(secuu))
secuu1 <- as.data.frame(secuu1)
secuu2 <- subset(secuu1, (secuu1$Freq>12))
vx1 <- as.vector(secuu2$Var1)
vx1 <- subset(vx1, !(vx1 == "000" | vx1 == "SO" ))
rflceb1 <- subset(rflc, (rflc$ZE_ID %in% vx1))
rflc <- rflceb1
rflc$EXP <- rflc$Ttot_immig
rflc$Wpost <- rflc$nativ
rflc$Wpre <- rflc$tot_nativ
rflc$DEP <- (rflc$Wpost - rflc$Wpre) / rflc$tot_pop
rflc <- subset(rflc, !(is.na(rflc$EXP)))
rflc <- subset(rflc, !(is.na(rflc$DEP)))
rflc <- subset(rflc, !(rflc$EXP < -0.1))
rflc <- subset(rflc, !(rflc$DEP > 10))
rflc <- subset(rflc, !(is.na(rflc$tot_pop)))
rflc$meandev <- 0
for (i in c(1:dim(rflc)[1])){
  ax <- rflc$ZE_ID[i]
  rflc$meandev[i] <- mean(rflc$DEP[rflc$ZE_ID == ax],na.rm=TRUE)
}
rflc$meandev <- rflc$DEP - rflc$meandev

rflcsave <- rflc
rflc <- rflcsave
rflc <- subset(rflc, (rflc$ZE_ID =="ZE1110")) 
thrx3 <- 0.14
rflc$meandev <- 0
for (i in c(1:dim(rflc)[1])){
  rflc$meandev[i] <- mean(rflc$DEP[rflc$codeAAU == rflc$codeAAU[i]])}
rflc$meandev <- rflc$DEP - rflc$meandev
rflc <- subset(rflc, (rflc$meandev < 1) )
rflc <- subset(rflc, (rflc$EXP < 0.6) )
min1 <- trunc(min(rflc$EXP*100, na.rm=TRUE) )
max1 <- trunc(max(rflc$EXP*100, na.rm=TRUE) )
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){
  y1$var[i-min1+1] <- mean(rflc$DEP[(rflc$EXP > y1$y[i-min1+1]) & (rflc$EXP < y1$y[i-min1+2])])}
y1 <- subset(y1, !is.na(y1$var))
for (i in c(1:dim(y1)[1])){
  y1$ind[i] <- if(y1$y[i]>thrx3){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= thrx3))
y1b <- subset(y1, (y1$y <= thrx3))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){
  if(y1$y[i] < thrx3){y1$fitc[i] <- NA}
  if(y1$y[i] > thrx3){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==thrx3){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
colora <- c("#bdbdbd","#525252","#525252","#525252","#525252")
f1 <-  xyplot(var   + fitc + fitc1 ~ y, data=y1,
              strip = FALSE, 
              pch = 1,
              type = c("p","l","l","l","l"),
              xlab="Parisian metropolis NW (ZE-1110)",
              ylab="",
              col=colora,
              abline=c(v=0.14, col=8), 
              distribute.type = TRUE) 



rflc <- rflcsave
rflc <- subset(rflc, (rflc$ZE_ID =="ZE0056")) 
thrx3 <- 0.27
rflc$meandev <- 0
for (i in c(1:dim(rflc)[1])){
  rflc$meandev[i] <- mean(rflc$DEP[rflc$codeAAU == rflc$codeAAU[i]])}
rflc$meandev <- rflc$DEP - rflc$meandev
rflc <- subset(rflc, (rflc$meandev < 1) )
rflc <- subset(rflc, (rflc$EXP < 0.6) )
min1 <- trunc(min(rflc$EXP*100, na.rm=TRUE) )
max1 <- trunc(max(rflc$EXP*100, na.rm=TRUE) )
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){
  y1$var[i-min1+1] <- mean(rflc$DEP[(rflc$EXP > y1$y[i-min1+1]) & (rflc$EXP < y1$y[i-min1+2])])}
y1 <- subset(y1, !is.na(y1$var))
for (i in c(1:dim(y1)[1])){
  y1$ind[i] <- if(y1$y[i]>thrx3){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= thrx3))
y1b <- subset(y1, (y1$y <= thrx3))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){
  if(y1$y[i] < thrx3){y1$fitc[i] <- NA}
  if(y1$y[i] > thrx3){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==thrx3){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
colora <- c("#bdbdbd","#525252","#525252","#525252","#525252")
f2 <- xyplot(var   + fitc + fitc1 ~ y, data=y1,
             strip = FALSE, 
             pch = 1,
             type = c("p","l","l","l","l"),
             xlab="Parisian metropolis NE (ZE-0056)",
             ylab="",
             col=colora,
             abline=c(v=0.27, col=8), 
             distribute.type = TRUE) 

rflc <- rflcsave
rflc <- subset(rflc, (rflc$ZE_ID =="ZE1115")) 
thrx3 <- 0.09
rflc$meandev <- 0
for (i in c(1:dim(rflc)[1])){
  rflc$meandev[i] <- mean(rflc$DEP[rflc$codeAAU == rflc$codeAAU[i]])}
rflc$meandev <- rflc$DEP - rflc$meandev
rflc <- subset(rflc, (rflc$meandev < 1) )
rflc <- subset(rflc, (rflc$EXP < 0.6) )
min1 <- trunc(min(rflc$EXP*100, na.rm=TRUE) )
max1 <- trunc(max(rflc$EXP*100, na.rm=TRUE) )
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){
  y1$var[i-min1+1] <- mean(rflc$DEP[(rflc$EXP > y1$y[i-min1+1]) & (rflc$EXP < y1$y[i-min1+2])])}
y1 <- subset(y1, !is.na(y1$var))
for (i in c(1:dim(y1)[1])){
  y1$ind[i] <- if(y1$y[i]>thrx3){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= thrx3))
y1b <- subset(y1, (y1$y <= thrx3))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){
  if(y1$y[i] < thrx3){y1$fitc[i] <- NA}
  if(y1$y[i] > thrx3){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==thrx3){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
colora <- c("#bdbdbd","#525252","#525252","#525252","#525252")
f3 <- xyplot(var   + fitc + fitc1 ~ y, data=y1,
             strip = FALSE, 
             pch = 1,
             type = c("p","l","l","l","l"),
             xlab="Parisian metropolis SE (ZE-1115)",
             ylab="",
             col=colora,
             abline=c(v=0.09, col=8), 
             distribute.type = TRUE) 


rflc <- rflcsave
rflc <- subset(rflc, (rflc$ZE_ID =="ZE0060")) #Saint-Etienne
thrx3 <- 0.05
rflc$meandev <- 0
for (i in c(1:dim(rflc)[1])){
  rflc$meandev[i] <- mean(rflc$DEP[rflc$codeAAU == rflc$codeAAU[i]])
}
rflc$meandev <- rflc$DEP - rflc$meandev
rflc <- subset(rflc, (rflc$meandev < 1) )
rflc <- subset(rflc, (rflc$EXP < 0.6) )
min1 <- trunc(min(rflc$EXP*100, na.rm=TRUE) )
max1 <- trunc(max(rflc$EXP*100, na.rm=TRUE) )
vec1 <- c((min1):(max1))
y<-vec1
vec2 <- vec1[-c(length(vec1))]
y<-y/100
y1 <- as.data.frame(y)
y1$var <- 0
for (i in vec2){
  y1$var[i-min1+1] <- mean(rflc$DEP[(rflc$EXP > y1$y[i-min1+1]) & (rflc$EXP < y1$y[i-min1+2])])
}
y1 <- subset(y1, !is.na(y1$var))
for (i in c(1:dim(y1)[1])){
  y1$ind[i] <- if(y1$y[i]>thrx3){1}else{0}}
y1$y2<- y1$y*y1$y
y1$y3<- y1$y*y1$y*y1$y
y1$y4<- y1$y*y1$y*y1$y*y1$y
y1a <- subset(y1, (y1$y >= thrx3))
y1b <- subset(y1, (y1$y <= thrx3))
lma <- lm(var ~ y+y2+y3, data=y1a)
lmb <- lm(var ~ y+y2+y3, data=y1b)
lmad <- as.data.frame(fitted(lma))
lmad$r <- row.names(lmad)
y1a$r <- row.names(y1a)
y1a <- left_join (y1a, lmad, by=c("r"))
lmbd <- as.data.frame(fitted(lmb))
lmbd$r <- row.names(lmbd)
y1b$r <- row.names(y1b)
y1b <- left_join (y1b, lmbd, by=c("r"))
y1a<-dplyr::rename(y1a, fita = `fitted(lma)`)
y1b<-dplyr::rename(y1b, fitb = `fitted(lmb)`)
y1a <- y1a[c(2,8)]
y1b <- y1b[c(2,8)]
y1 <- left_join(y1, y1a, by=c("var"))
y1 <- left_join(y1, y1b, by=c("var"))
y1 <- subset(y1, !(is.na(y1$var)))
lmc <- lm(var ~ y+y2+y3+y4+ind, data=y1)
y1$fitc <- fitted(lmc)
y1$fitc1 <- y1$fitc
for(i in c(1:dim(y1)[1])){
  if(y1$y[i] < thrx3){y1$fitc[i] <- NA}
  if(y1$y[i] > thrx3){y1$fitc1[i] <- NA}}
for(i in c(1:dim(y1)[1])){  if(y1$y[i] ==thrx3){y1$fitc[i] <- y1$fitc[i+1] * (y1$fitc[i+1]/y1$fitc[i+2])}}
colora <- c("#bdbdbd","#525252","#525252","#525252","#525252")
f4 <- xyplot(var   + fitc + fitc1 ~ y, data=y1,
             strip = FALSE, 
             pch = 1,
             type = c("p","l","l","l","l"),
             xlab="Saint-Etienne (ZE-0060)",
             ylab="",
             col=colora,
             abline=c(v=0.05, col=8), 
             distribute.type = TRUE) 



print(f1, position=c(0,0.49, 0.51,1), more=TRUE)
print(f2, position=c(0.49,0.49, 1,1), more=TRUE)
print(f3, position=c(0,0, 0.51,0.51), more=TRUE)
print(f4, position=c(0.49,0, 1,0.51))


################################################################################
### TABLE - Tipping and distance to a QPV or ZUS (priority districts)
################################################################################

pathToShp <- "./QPV"
ogrInfo(dsn = pathToShp,layer="QP_METROPOLE_LB93")
comm <- readOGR(dsn = pathToShp, layer="QP_METROPOLE_LB93", stringsAsFactors=FALSE)
df_qpv <- as.data.frame(comm@data)
df_qpv1<- as.data.frame(coordinates(comm))
df_qpv$coord1 <- df_qpv1$V1
df_qpv$coord2 <- df_qpv1$V2
pathToShp <- "./ZUS"
ogrInfo(dsn = pathToShp,layer="ZUS_FRM_BDA09_L93")
comm2 <- readOGR(dsn = pathToShp, layer="ZUS_FRM_BDA09_L93", stringsAsFactors=FALSE)
df_zus <- as.data.frame(comm2@data)
df_zus1<- as.data.frame(coordinates(comm2))
df_zus$coord1 <- df_zus1$V1
df_zus$coord2 <- df_zus1$V2
pathToShp <- "./CONTOUR_IRIS"
ogrInfo(dsn = pathToShp,layer="CONTOURS-IRIS")
comm1 <- readOGR(dsn = pathToShp, layer="CONTOURS-IRIS", stringsAsFactors=FALSE)
df_iris <- as.data.frame(comm1@data)
df_iris1<- as.data.frame(coordinates(comm1))
df_iris$coord1 <- df_iris1$V1
df_iris$coord2 <- df_iris1$V2
ma <- df_qpv[c(4,5)]
ma <- as.matrix(ma)
maz <- df_zus[c(6,7)]
maz <- as.matrix(maz)
df_qpv$new <- 0
for (i in c(1:dim(df_qpv)[1])){
  pt <- c(df_qpv$coord1[i], df_qpv$coord2[i])
  vecd <- spDistsN1(maz, pt ,longlat = FALSE)
  vecdm <- min(vecd)
  df_qpv$new[i] <- vecdm}
df_newqpv <- subset(df_qpv, (df_qpv$new > 1000))
man <- df_newqpv[c(4,5)]
man <- as.matrix(man)
df_iris$dist_qpv <- 1000000
df_iris$dist_zus <- 1000000
df_iris$dist_newqpv <- 1000000
for (i in c(1:dim(df_iris)[1])){
  ptiri <- c(df_iris$coord1[i], df_iris$coord2[i])
  vecd <- spDistsN1(man, ptiri ,longlat = FALSE)
  vecdm <- min(vecd)
  df_iris$dist_newqpv[i] <- vecdm}
for (i in c(1:dim(df_iris)[1])){
  ptiri <- c(df_iris$coord1[i], df_iris$coord2[i])
  vecd <- spDistsN1(ma, ptiri ,longlat = FALSE)
  vecdm <- min(vecd)
  df_iris$dist_qpv[i] <- vecdm}
for (i in c(1:dim(df_iris)[1])){
  ptiri <- c(df_iris$coord1[i], df_iris$coord2[i])
  vecd <- spDistsN1(maz, ptiri ,longlat = FALSE)
  vecdm <- min(vecd)
  df_iris$dist_zus[i] <- vecdm}
df_iris <- df_iris[-c(3)]
df_iris <- dplyr::rename(df_iris, iris = CODE_IRIS)

##Choose decade 1 or 2 
#rflc2 <- read.csv("fournel2023d_thres_dec1.csv", sep=",")
rflc2 <- read.csv("fournel2023d_thres_dec2.csv", sep=",")
rflc <- rflc2
rflc <- dplyr::rename(rflc, iris = iris2)
viris <- intersect(df_iris$iris, rflc$iris)
rflcA <- subset(rflc, (rflc$iris %in% viris))
rflc <- left_join(rflcA, df_iris, by=c("iris"))

##Adjust for type of tipping point
#rflc$delta <- rflc$EXP - (rflc$thres_m1/100)
rflc$delta <- rflc$EXP - (rflc$thres_m2)
rflc$delta2 <- rflc$delta*rflc$delta
rflc$delta3 <- rflc$delta*rflc$delta*rflc$delta
rflc$delta4 <- rflc$delta*rflc$delta*rflc$delta*rflc$delta
rflc$dummy <- 0
for (i in c(1:dim(rflc)[1])){  if(rflc$delta[i] > 0) {rflc$dummy[i] <- 1}}
coord <- rflc[c("coord1","coord2")]
fraction <- (5.1/dim(coord)[1])
coord <- as.matrix(coord)
rflc$dist_neiD <- NA
i<- 2
for (i in c(1:dim(rflc)[1])){
  ptiri <- c(rflc$coord1[i], rflc$coord2[i])
  vecd <- spDistsN1(coord, ptiri ,longlat = FALSE)
  rflc$dist_nei <- vecd
  vecq <- quantile( rflc$dist_nei, fraction, na.rm=TRUE)
  rflcB <- subset(rflc, (rflc$dist_nei <=vecq & rflc$dist_nei >0.0000001))
  sumdummy <- sum(rflcB$dummy)
  rflc$dist_neiD[i] <- if(sumdummy < 1){1}else{0}}
rflc$dist_neiDu <- rflc$dist_neiD * rflc$dummy
rflc_ext <- subset(rflc, (rflc$EXP >0.15))
coord <- rflc_ext[c(102,103)]
coord <- as.matrix(coord)
rflc$dist_ghetto <- NA
for (i in c(1:dim(rflc)[1])){
  ptiri <- c(rflc$coord1[i], rflc$coord2[i])
  vecd <- spDistsN1(coord, ptiri ,longlat = FALSE)
  rflc$dist_ghetto[i] <- min(vecd)}
rflc$dist_neiD <- NA
for (i in c(1:dim(rflc)[1])){
  ptiri <- c(rflc$coord1[i], rflc$coord2[i])
  vecd <- spDistsN1(coord, ptiri ,longlat = FALSE)
  rflc$dist_nei <- vecd
  vecq <- quantile( rflc$dist_nei, fraction, na.rm=TRUE)
  rflcB <- subset(rflc, (rflc$dist_nei <vecq & rflc$dist_nei >0.01))
  sumdummy <- sum(rflcB$dummy)
  rflc$dist_neiD[i] <- if(sumdummy < 1){1}else{0}}
rflc$dist_neiDu <- rflc$dist_neiD * rflc$dummy
rflc$qpv_1 <- NA
rflc$qpv_2 <- NA
rflc$qpv_3 <- NA
rflc$qpv_4 <- NA
for(i in c(1:dim(rflc)[1])){
  rflc$qpv_1[i] <- if(rflc$dist_qpv[i] < 1001){1}else{0}
  rflc$qpv_2[i] <- if(rflc$dist_qpv[i] > 1001 & rflc$dist_qpv[i] < 3001){1}else{0}
  rflc$qpv_3[i] <- if(rflc$dist_qpv[i]> 3001 & rflc$dist_qpv[i] < 100000000000){1}else{0}}
rflc$qpv_1D <- rflc$qpv_1 * rflc$dummy
rflc$qpv_2D <- rflc$qpv_2 * rflc$dummy
rflc$qpv_3D <- rflc$qpv_3 * rflc$dummy
rflc$newqpv_1 <- NA
rflc$newqpv_2 <- NA
rflc$newqpv_3 <- NA
rflc$newqpv_4 <- NA
for(i in c(1:dim(rflc)[1])){
  rflc$newqpv_1[i] <- if(rflc$dist_newqpv[i] < 1001){1}else{0}
  rflc$newqpv_2[i] <- if(rflc$dist_newqpv[i] > 1001 & rflc$dist_newqpv[i] < 3001){1}else{0}
  rflc$newqpv_3[i] <- if(rflc$dist_newqpv[i]> 3001 & rflc$dist_newqpv[i] < 100000000){1}else{0}}
rflc$newqpv_1D <- rflc$newqpv_1 * rflc$dummy
rflc$newqpv_2D <- rflc$newqpv_2 * rflc$dummy
rflc$newqpv_3D <- rflc$newqpv_3 * rflc$dummy
rflc$zus_1 <- NA
rflc$zus_2 <- NA
rflc$zus_3 <- NA
rflc$zus_4 <- NA
for(i in c(1:dim(rflc)[1])){
  rflc$zus_1[i] <- if(rflc$dist_zus[i] < 1001){1}else{0}
  rflc$zus_2[i] <- if(rflc$dist_zus[i] > 1001 & rflc$dist_zus[i] < 3001){1}else{0}
  rflc$zus_3[i] <- if(rflc$dist_zus[i]> 3001 & rflc$dist_zus[i] < 10000000){1}else{0}}
rflc$zus_1D <- rflc$zus_1 * rflc$dummy
rflc$zus_2D <- rflc$zus_2 * rflc$dummy
rflc$zus_3D <- rflc$zus_3 * rflc$dummy
#rflc$ghetto_1 <- NA
#rflc$ghetto_2 <- NA
#rflc$ghetto_3 <- NA
#for(i in c(1:dim(rflc)[1])){
#  rflc$ghetto_1[i] <- if(rflc$dist_ghetto[i] < 1001){1}else{0}
#  rflc$ghetto_2[i] <- if(rflc$dist_ghetto[i] > 1001 & rflc$dist_ghetto[i] < 3001){1}else{0}
#  rflc$ghetto_3[i] <- if(rflc$dist_ghetto[i]> 3001 & rflc$dist_ghetto[i] < 100000000000){1}else{0}}
#rflc$ghetto_1D <- rflc$ghetto_1 * rflc$dummy
#rflc$ghetto_2D <- rflc$ghetto_2 * rflc$dummy
#rflc$ghetto_3D <- rflc$ghetto_3 * rflc$dummy
rflc$DEP <- rflc$DEP*100
rflc$regions <- substr(rflc$ZE_ID,3,4)

#Choose the model: for columns 1,3,5 and 2,4,6 respectively 

#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome+logementsvacants+ Touvr_pop +zus_2D+zus_3D+factor(ZE_ID), data=rflc, weights=rflc$tot_pop)
#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome+logementsvacants+ Touvr_pop +qpv_2D+qpv_3D+factor(ZE_ID), data=rflc, weights=rflc$tot_pop)
#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome+logementsvacants+ Touvr_pop +newqpv_2D+newqpv_3D+factor(ZE_ID), data=rflc, weights=rflc$tot_pop)
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome_2010+log_vac_2010+ csp +zus_2D+zus_3D+factor(ZE_ID), data=rflc, weights=rflc$pop_tot_2010)
#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome_2010+log_vac_2010+ csp +qpv_2D+qpv_3D+factor(ZE_ID), data=rflc, weights=rflc$pop_tot_2010)
#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome_2010+log_vac_2010+ csp +newqpv_2D+newqpv_3D+factor(ZE_ID), data=rflc, weights=rflc$pop_tot_2010)

summary(reg_lin)
reg1 <- as.matrix(coeftest(reg_lin, vcov. = vcovHC(reg_lin,type = "HC0", cluster = "regions")))
beta1 <- reg1[6,1]
beta2 <- reg1[11,1]
beta4 <- reg1[12,1]
beta3 <- beta1+beta2
beta5 <- beta1+beta4
se1 <- reg1[6,2]
se2 <- reg1[11,2]
se4 <- reg1[12,2]
matx <- vcovHC(reg_lin, type = "HC0", cluster = "regions")
cova <- matx[11,6]
covb <- matx[12,6]
se3 <- sqrt(se1*se1+se2*se2+2*cova)
se5 <- sqrt(se1*se1+se4*se4+2*covb)
beta1
se1
beta2
se2
beta3
se3
beta4
se4
beta5
se5

#Choose the model for columns 7 and 8
#reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome+logementsvacants+ Touvr_pop +dist_neiDu+factor(ZE_ID), data=rflc, weights=rflc$tot_pop)
reg_lin <- lm(DEP ~ delta+delta2+delta3+delta4+dummy+chomage+sansdiplome_2010+log_vac_2010+ csp +dist_neiDu+factor(ZE_ID), data=rflc, weights=rflc$pop_tot_2010)
summary(reg_lin)
reg1 <- as.matrix(coeftest(reg_lin, vcov. = vcovHC(reg_lin,type = "HC0", cluster = "regions")))
beta1 <- reg1[6,1]
beta2 <- reg1[11,1]
beta3 <- beta1+beta2
se1 <- reg1[6,2]
se2 <- reg1[11,2]
matx <- vcovHC(reg_lin, type = "HC0", cluster = "regions")
cova <- matx[11,6]
se3 <- sqrt(se1*se1+se2*se2+2*cova)
beta1
se1
beta2
se2
beta3
se3


################################################################################
### TABLE - Tipping and vote shares or political attitudes
################################################################################


rflc1 <- read.csv("fournel2023d_controls_iris_1999.csv",sep=";")
rflc2 <- read.csv("fournel2023d_controls_iris_2010.csv",sep=";")
v <- intersect(rflc1$iris2,rflc2$iris2)
rflc1<-subset(rflc1, (rflc1$iris2 %in% v))
rflc2<-subset(rflc2, (rflc2$iris2 %in% v))
rflc<-left_join(rflc1,rflc2, by=c("iris2"))
rflc$depcom <- substr(rflc$iris2,1,5)
aau <- read_excel("AAU.xls")
ref_geo <- read.csv("ref_geo.csv", sep=";")
ref_geo <- dplyr::rename(ref_geo, depcom = COM_CODE)
rflc <- left_join(rflc, ref_geo, by=c("depcom"))
rflc <- left_join(rflc, aau, by=c("depcom"))
rflc$Tcpis2010 <- rflc$cpis2010 / rflc$poptot2010
rflc$Tint2010 <- rflc$int2010 / rflc$poptot2010
rflc$Templ2010 <- rflc$empl2010 / rflc$poptot2010
rflc$Touvr2010 <- rflc$ouvr2010 / rflc$poptot2010
rflc$nativ2010 <-  rflc$poptot2010 -rflc$immig2010
cols = c(21:41)    
rflc[,cols] = apply(rflc[,cols], 2, function(x) as.numeric(as.character(x)))
rm(rflc1,rflc2,cols,v,aau)
r1 <- rflc[c(1,2)]
hous1 <- read_xlsx("fournel2023d_controls_housing.xlsx",sheet=1)
hous2 <- read_xlsx("fournel2023d_controls_housing.xlsx",sheet=2)
hous3 <- read_xlsx("fournel2023d_controls_housing.xlsx",sheet=3)
hous4 <- read_xlsx("fournel2023d_controls_housing.xlsx",sheet=4)
hous1 <- hous1[-c(3,8)]
hous1$depcom <- substr(hous1$iris2,1,5)
hous1 <- na.omit(hous1)
hous1 <- left_join(r1,hous1)
hous1$room <- hous1$tot_pop/ hous1$resid_persperroom
hous1 <- hous1[-c(1,8)]
hous1 <- na.omit(hous1)
hous1 <- subset(hous1, !hous1$room > 1E20)
hous1 <- aggregate(cbind(tot_pop, logements_tot_1999, resid_princ_tot_1999, resid_maisonindiv_1999,resid_proprio, resid_hlm, room  )~depcom , data=hous1 , sum)
vparis <- c("75101","75102","75103","75104","75105","75106","75107","75108","75109","75110","75111","75112","75113","75114","75115","75116","75117","75118","75119","75120","75001","75002","75003","75004","75005","75006","75007","75008","75009","75010","75011","75012","75013","75014","75015","75016","75017","75018","75019","75020")
vlyon <- c("69381","69382","69383","69384","69385","69386","69387","69388","69389")
vmarseille <- c("13201","13202","13203","13204","13205","13206","13207","13208","13209","13210","13211","13212","13213","13214","13215","13216","13331","13332","13333","13334","13335","13336","13337","13338","13339","13340","13341","13342","13343","13344","13345","13346")
vall <- c(vparis, vlyon, vmarseille)
for(i in c(1:dim(hous1)[1])){if(hous1$depcom[i] %in% vparis){hous1$depcom[i]<-"75056"}}
for(i in c(1:dim(hous1)[1])){if(hous1$depcom[i] %in% vlyon){hous1$depcom[i]<-"69123"}}
for(i in c(1:dim(hous1)[1])){if(hous1$depcom[i] %in% vmarseille){hous1$depcom[i]<-"13055"}}
hous1 <- aggregate(cbind(tot_pop, logements_tot_1999, resid_princ_tot_1999, resid_maisonindiv_1999,resid_proprio, resid_hlm, room  )~depcom , data=hous1 , sum)
r2 <- hous3
r2 <- na.omit(r2)
r2 <- r2[-c(3)]
hous1 <- left_join(hous1,r2)
hous1 <- na.omit(hous1)
ref_geo <- ref_geo[c(6,17)]
hous1 <- left_join(hous1, ref_geo)
hous1 <- hous1[-c(1)]
hous1$part_log_vac_1999 <- hous1$part_log_vac_1999*hous1$logements_tot_1999*0.01
hous1 <- aggregate(cbind(tot_pop, logements_tot_1999, resid_princ_tot_1999, resid_maisonindiv_1999,resid_proprio, resid_hlm, room ,part_log_vac_1999 )~ZE_ID , data=hous1 , sum)
hous1$log_vac <- hous1$part_log_vac_1999 / hous1$logements_tot_1999
hous1$perroom <- hous1$tot_pop / hous1$room
hous1$proprio <- hous1$resid_proprio/hous1$resid_princ_tot_1999
hous1$hlm <- hous1$resid_hlm/hous1$resid_princ_tot_1999
hous1$maison <- hous1$resid_maisonindiv_1999/hous1$resid_princ_tot_1999
hous1 <- hous1[c(1:4,10:14)]
colnames(hous1)[c(2:4)]<- c("pop_tot","log_tot","resid_tot")
hous1 <- subset(hous1, !hous1$ZE_ID=="SO"&!hous1$ZE_ID=="ZE9999")
#The average number of rooms for houses of 6 rooms or more has been computed assuming the distribution of houses...
#... classified along their number of rooms follows a Poisson distribution with lambda=4
hous2$room <- hous2$resid_1room*1+hous2$resid_2room*2+hous2$resid_3room*3+hous2$resid_4room*4+hous2$resid_5room*5+hous2$resid_6roomp*6.92
r2 <- left_join(hous3,hous4)
r2 <- r2[-c(2)]
hous2 <- subset(hous2, !hous2$depcom%in%vall)
hous2 <- left_join(hous2, r2)
hous2 <- hous2[-c(5:10)]
hous2 <- left_join(hous2, ref_geo)
r1 <- rflc[c(1,42)]
r1$depcom <- substr(r1$iris2,1,5)
r1 <- na.omit(r1)
r1 <- r1[-c(1)]
for(i in c(1:dim(r1)[1])){if(r1$depcom[i] %in% vparis){r1$depcom[i]<-"75056"}}
for(i in c(1:dim(r1)[1])){if(r1$depcom[i] %in% vlyon){r1$depcom[i]<-"69123"}}
for(i in c(1:dim(r1)[1])){if(r1$depcom[i] %in% vmarseille){r1$depcom[i]<-"13055"}}
r1 <- aggregate(cbind(poptot2010)~depcom, data=r1, sum)
hous2 <- left_join(r1,hous2)
hous2$part_log_vac_2008 <- hous2$part_log_vac_2008*hous2$log_tot_2008*0.01
hous2 <- aggregate(cbind(poptot2010, log_tot_2008, resid_tot_2010, resid_maisonindiv_2010,resid_proprio_2010, resid_hlm_2010, room ,part_log_vac_2008 )~ZE_ID , data=hous2 , sum)
hous2$log_vac <- hous2$part_log_vac_2008 / hous2$log_tot_2008
hous2$perroom <- hous2$poptot2010 / hous2$room
hous2$proprio <- hous2$resid_proprio_2010/hous2$resid_tot_2010
hous2$hlm <- hous2$resid_hlm_2010/hous2$resid_tot_2010
hous2$maison <- hous2$resid_maisonindiv_2010/hous2$resid_tot_2010
hous2 <- hous2[c(1:4,10:14)]
colnames(hous2)[c(2:4)]<- c("pop_tot","log_tot","resid_tot")
hous2 <- subset(hous2, !hous2$ZE_ID=="SO" & !hous2$ZE_ID=="ZE9999")
hous99 <- hous1
hous10 <- hous2
#Model for the impact of IPW on some housing variables
houstot <- left_join(hous99, hous10, by="ZE_ID")
ze <- read_excel("fournel2023a_main_ze.xlsx",sheet=3)
ze$regions <- as.factor(substr(ze$ZE_ID,3,4))
ze$zone <- substr(ze$ZE_ID,3,3)
ze$ipw_fr_autor <- ze$ipw_fr_autor/1000
ze$ipw_oth_autor <- ze$ipw_oth_autor/1000
ze <- subset(ze, ze$year=="y1999")
ze <- left_join(ze, houstot)
ze$depen <- (ze$proprio.y-ze$proprio.x) * 100
m_iv <- ivreg(depen ~   factor(regions)+share_indus_1999 + fem_1999+immig_1999+diplosup_1999+prec_1999+new_routine+new_apr+new_offshore_centered|ipw_fr_autor|ipw_oth_autor, data=ze, weights=ze$pop_tot_1999)
summary(m_iv)
coef_test(m_iv, vcov = "CR1", cluster = ze$zone, test = "naive-t")
rm(r1,r2,hous3,hous4,hous1,hous2)
rflc2 <- read.csv("fournel2023d_thres_dec1.csv", sep=",")
rflc2 <- rflc2[c("ZE_ID","thres_m1","thres_m2")]
rflc2$thres_m2 <- round(rflc2$thres_m2*100, digits=1)
rflc2 <- unique(rflc2)
rflc2 <- left_join(rflc2, hous99)
rflc2$regions <- substr(rflc2$ZE_ID,3,4)
rflc2$zone <- substr(rflc2$regions,1,1)
rflc2s <- rflc2
elec <- read.csv("fournel2023c_elect_b.csv", sep=",")
elec$EXG <- elec$extrgauche_voix_2002
elec$CEG <- elec$centregauche_voix_2002
elec$CED <- elec$centre_voix_2002
elec$DRO <- elec$droite_voix_2002
elec$EXD <- elec$extdroite_voix_2002
elec$EXP <- elec$nbexprim2002
elec <- elec[c("depcom","EXG","CEG","CED","DRO","EXD","EXP")]
elec <- left_join(elec, ref_geo)
elec <- na.omit(elec)
elec <- elec[-c(1)]
elec <- aggregate(cbind(EXG,CEG,CED,DRO,EXD,EXP)~ZE_ID, data=elec, sum)
elec <- subset(elec, !elec$ZE_ID=="SO" & !elec$ZE_ID=="ZE9999")
elec$EXG <- elec$EXG / elec$EXP * 100
elec$CEG <- elec$CEG / elec$EXP* 100
elec$CED <- elec$CED / elec$EXP* 100
elec$DRO <- elec$DRO / elec$EXP* 100
elec$EXD <- elec$EXD / elec$EXP* 100
rflc2 <- left_join(rflc2, elec)
rflc2$COAG <- rflc2$EXG+rflc2$CEG
rflc2$COAD <- rflc2$CED+rflc2$DRO
lm1 <- lm(thres_m1 ~EXD+COAD+ perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")
lm1 <- lm(thres_m2 ~EXD+COAD+ perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")

elec <- read.csv("fournel2023c_elect_b.csv", sep=",")
elec$EXG <- elec$extrgauche_voix_2007
elec$CEG <- elec$centregauche_voix_2007
elec$CED <- elec$centre_voix_2007
elec$DRO <- elec$droite_voix_2007
elec$EXD <- elec$extdroite_voix_2007
elec$EXP <- elec$exprim_2007t1
elec <- elec[c("depcom","EXG","CEG","CED","DRO","EXD","EXP")]
elec <- left_join(elec, ref_geo)
elec <- na.omit(elec)
elec <- elec[-c(1)]
elec <- aggregate(cbind(EXG,CEG,CED,DRO,EXD,EXP)~ZE_ID, data=elec, sum)
elec <- subset(elec, !elec$ZE_ID=="SO" & !elec$ZE_ID=="ZE9999")
elec$EXG <- elec$EXG / elec$EXP * 100
elec$CEG <- elec$CEG / elec$EXP* 100
elec$CED <- elec$CED / elec$EXP* 100
elec$DRO <- elec$DRO / elec$EXP* 100
elec$EXD <- elec$EXD / elec$EXP* 100
rflc2 <- left_join(rflc2s, elec)
rflc2$COAG <- rflc2$EXG+rflc2$CEG
rflc2$COAD <- rflc2$CED+rflc2$DRO
lm1 <- lm(thres_m1 ~EXD+ COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")
lm1 <- lm(thres_m2 ~EXD+ COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")

rflc2 <- read.csv("fournel2023d_thres_dec2.csv", sep=",")
rflc2 <- rflc2[c("ZE_ID","thres_m1","thres_m2")]
rflc2$thres_m2 <- round(rflc2$thres_m2*100, digits=1)
rflc2 <- unique(rflc2)
rflc2 <- left_join(rflc2, hous10)
rflc2$regions <- substr(rflc2$ZE_ID,3,4)
rflc2$zone <- substr(rflc2$regions,1,1)
rflc2s <- rflc2
elec <- read.csv("fournel2023c_elect_b.csv", sep=",")
elec$EXG <- elec$extrgauche_voix_2012
elec$CEG <- elec$centregauche_voix_2012
elec$CED <- elec$centre_voix_2012
elec$DRO <- elec$droite_voix_2012
elec$EXD <- elec$extdroite_voix_2012
elec$EXP <- elec$nbexprim2012
elec <- elec[c("depcom","EXG","CEG","CED","DRO","EXD","EXP")]
elec <- left_join(elec, ref_geo)
elec <- na.omit(elec)
elec <- elec[-c(1)]
elec <- aggregate(cbind(EXG,CEG,CED,DRO,EXD,EXP)~ZE_ID, data=elec, sum)
elec <- subset(elec, !elec$ZE_ID=="SO" & !elec$ZE_ID=="ZE9999")
elec$EXG <- elec$EXG / elec$EXP * 100
elec$CEG <- elec$CEG / elec$EXP* 100
elec$CED <- elec$CED / elec$EXP* 100
elec$DRO <- elec$DRO / elec$EXP* 100
elec$EXD <- elec$EXD / elec$EXP* 100
rflc2 <- left_join(rflc2s, elec)
rflc2$COAG <- rflc2$EXG+rflc2$CEG
rflc2$COAD <- rflc2$CED+rflc2$DRO
lm1 <- lm(thres_m1 ~EXD+COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")
lm1 <- lm(thres_m2 ~EXD+COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")

lm1 <- lm(thres_m1 ~EXD+COAD+factor(regions)+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")

elec <- read.csv("fournel2023c_elect_b.csv", sep=",")
elec$EXG <- elec$extrgauche_2017
elec$CEG <- elec$centregauche_2017
elec$CED <- elec$centre_2017
elec$DRO <- elec$droite_2017
elec$EXD <- elec$extdroite_2017
elec$EXP <- elec$nbexprim2017
elec <- elec[c("depcom","EXG","CEG","CED","DRO","EXD","EXP")]
elec <- left_join(elec, ref_geo)
elec <- na.omit(elec)
elec <- elec[-c(1)]
elec <- aggregate(cbind(EXG,CEG,CED,DRO,EXD,EXP)~ZE_ID, data=elec, sum)
elec <- subset(elec, !elec$ZE_ID=="SO" & !elec$ZE_ID=="ZE9999")
elec$EXG <- elec$EXG / elec$EXP * 100
elec$CEG <- elec$CEG / elec$EXP* 100
elec$CED <- elec$CED / elec$EXP* 100
elec$DRO <- elec$DRO / elec$EXP* 100
elec$EXD <- elec$EXD / elec$EXP* 100
rflc2 <- left_join(rflc2s, elec)
rflc2$COAG <- rflc2$EXG+rflc2$CEG
rflc2$COAD <- rflc2$CED+rflc2$DRO

lm1 <- lm(thres_m1 ~EXD+COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")
lm1 <- lm(thres_m2 ~EXD+COAD+perroom+proprio+hlm+maison, data=rflc2, weights = rflc2$pop_tot )
summary(lm1)
coef_test(lm1, vcov = "CR1", cluster = rflc2$zone, test = "naive-t")


